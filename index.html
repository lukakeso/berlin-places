<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Berlin Places — Interactive Map</title>
  <meta name="description" content="Companion map to the book 'Places' by Tine Fetz & Daniel Schneider. Explore 60 underground club and subculture locations across Berlin on an interactive illustrated map.">
  <meta name="keywords" content="Berlin underground places, Berlin underground places book, Berlin club subculture map, Places book Ventil Verlag, Tine Fetz, Daniel Schneider, Vergangene Orte Berlin, Berlin underground history">
  <meta name="robots" content="index, follow">
  <meta name="author" content="lukakeso">
  <meta name="theme-color" content="#1a1a1a">
  <link rel="canonical" href="https://lukakeso.github.io/berlin-places/">
  <link rel="alternate" hreflang="en" href="https://lukakeso.github.io/berlin-places/">
  <link rel="alternate" hreflang="de" href="https://lukakeso.github.io/berlin-places/">
  <link rel="alternate" hreflang="x-default" href="https://lukakeso.github.io/berlin-places/">

  <!-- Favicons -->
  <link rel="icon" type="image/png" sizes="32x32" href="assets/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="assets/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="assets/apple-touch-icon.png">

  <!-- Open Graph / social sharing -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://lukakeso.github.io/berlin-places/">
  <meta property="og:site_name" content="Berlin Places — Interactive Map">
  <meta property="og:locale" content="en_US">
  <meta property="og:title" content="Berlin Places — Interactive Map">
  <meta property="og:description" content="Companion map to the book 'Places' by Tine Fetz & Daniel Schneider. Explore 60 underground club and subculture locations across Berlin on an interactive illustrated map.">
  <meta property="og:image" content="https://lukakeso.github.io/berlin-places/assets/og_preview.png">
  <meta property="og:image:alt" content="Illustrated map of Berlin with marked places of interest">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">

  <!-- Twitter / X Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:site" content="@lukakeso">
  <meta name="twitter:title" content="Berlin Places — Interactive Map">
  <meta name="twitter:description" content="Companion map to the book 'Places' by Tine Fetz & Daniel Schneider. Explore 60 underground club and subculture locations across Berlin on an interactive illustrated map.">
  <meta name="twitter:image" content="https://lukakeso.github.io/berlin-places/assets/og_preview.png">

  <!-- Structured data -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Berlin Places — Interactive Map",
    "url": "https://lukakeso.github.io/berlin-places/",
    "description": "Companion map to the book 'Places' by Tine Fetz & Daniel Schneider. Explore 60 underground club and subculture locations across Berlin on an interactive illustrated map.",
    "applicationCategory": "TravelApplication",
    "operatingSystem": "Any",
    "inLanguage": ["en", "de"],
    "keywords": "Berlin underground places, Berlin club subculture, Places book, Tine Fetz, Daniel Schneider, Ventil Verlag",
    "author": {
      "@type": "Person",
      "name": "lukakeso"
    },
    "about": {
      "@type": "City",
      "name": "Berlin",
      "addressCountry": "DE"
    },
    "isBasedOn": {
      "@type": "Book",
      "name": "Places — Vergangene Orte der Berliner Club- und Subkultur",
      "author": [
        { "@type": "Person", "name": "Tine Fetz" },
        { "@type": "Person", "name": "Daniel Schneider" }
      ],
      "publisher": { "@type": "Organization", "name": "Ventil Verlag" }
    }
  }
  </script>
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      width: 100vw;
      height: 100dvh;
      overflow: hidden;
      background: #fff;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
    }

    /* ── Load screen ──────────────────────────────────────────────── */
    #load-screen {
      position: fixed;
      inset: 0;
      background: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 3000;
      flex-direction: column;
      gap: 10px;
    }
    #load-screen.hidden { display: none; }

    #load-card {
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }
    #load-card h1 {
      font-size: 22px;
      font-weight: 700;
      color: #1a1a1a;
    }
    #load-card p {
      font-size: 14px;
      color: #666;
      line-height: 1.6;
    }
    #load-card code {
      background: #f0f0f0;
      padding: 1px 5px;
      border-radius: 3px;
      font-size: 13px;
    }
    #load-btn {
      padding: 10px 28px;
      background: #1a1a1a;
      color: #fff;
      border: none;
      border-radius: 8px;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s;
    }
    #load-btn:hover { background: #333; }
    #load-error {
      font-size: 13px;
      color: #c0392b;
      display: none;
    }
    #load-error.visible { display: block; }

    /* ── Map ──────────────────────────────────────────────────────── */
    #map-viewport {
      position: relative;
      width: 100vw;
      height: 100dvh;
      overflow: hidden;
      cursor: grab;
      user-select: none;
    }
    #map-viewport.grabbing  { cursor: grabbing; }
    /* #map-viewport.edit-mode { cursor: crosshair; } */

    #map-wrapper {
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
    }

    /* ── Crosshairs ───────────────────────────────────────────────── */
    #ch-left, #ch-right, #cv-top, #cv-bottom {
      position: absolute;
      pointer-events: none;
      display: none;
      opacity: 0.65;
    }
    #ch-left, #ch-right {
      height: 0;
      border-top: var(--hs-border, 2px) dotted #E74111;
    }
    #ch-left  { left: 0; }
    #ch-right { right: 0; }
    #cv-top, #cv-bottom {
      width: 0;
      border-left: var(--hs-border, 2px) dotted #E74111;
    }
    #cv-top    { top: 0; }
    #cv-bottom { bottom: 0; }

    #map-image {
      display: block;
      max-width: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    /* ── Hotspots ─────────────────────────────────────────────────── */
    .hotspot {
      position: absolute;
      width: var(--hs-size, 36px);
      height: var(--hs-size, 36px);
      transform: translate(-50%, -50%);
      cursor: pointer;
      z-index: 10;
      clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
    }

    .hotspot-ring {
      position: absolute;
      inset: var(--hs-inset, 6px);
      border-radius: 2px;
      border: var(--hs-border, 2px) solid transparent;
      background: transparent;
      transform: rotate(45deg);
      transition: background 0.15s, border-color 0.15s, box-shadow 0.15s;
      pointer-events: none;
    }

    .hotspot-label {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      font-weight: 700;
      color: transparent;
      pointer-events: none;
      transition: color 0.15s;
      visibility: hidden; /* hidden for now; remove to re-enable numbers */
    }

    /* Normal hover */
    .hotspot:hover .hotspot-ring {
      border-color: #E74111;
      background: rgba(231, 65, 17, 0.12);
      box-shadow: 0 0 8px rgba(231, 65, 17, 0.40);
    }
    .hotspot:hover .hotspot-label { color: #fff; }

    /* Edit mode styles — disabled
    .edit-mode .hotspot-ring { background: rgba(231, 65, 17, 0.08); }
    .edit-mode .hotspot-label { color: rgba(231, 65, 17, 0.80); }
    .edit-mode .hotspot:hover .hotspot-ring {
      background: rgba(231, 65, 17, 0.28);
      box-shadow: 0 0 10px rgba(231, 65, 17, 0.45);
    } */

    /* Selected location (panel open) */
    .hotspot.active .hotspot-ring {
      border-color: #E74111;
      background: transparent;
      box-shadow: 0 0 6px rgba(231, 65, 17, 0.35);
    }

    /* Cross-reference linked group (persistent until navigating away) */
    .hotspot.linked .hotspot-ring {
      border-color: #E74111;
      background: rgba(231, 65, 17, 0.12);
      box-shadow: 0 0 8px rgba(231, 65, 17, 0.40);
    }

    /* Highlighted from text reference hover */
    .hotspot.highlighted .hotspot-ring {
      border-color: #E74111;
      background: rgba(231, 65, 17, 0.18);
      box-shadow: 0 0 12px rgba(231, 65, 17, 0.55);
    }

    /* Dragging hotspot styles — disabled
    .hotspot.dragging-hs { z-index: 20; cursor: grabbing !important; }
    .hotspot.dragging-hs .hotspot-ring {
      background: rgba(30, 140, 255, 0.35) !important;
      border-color: rgba(30, 140, 255, 0.90) !important;
      box-shadow: 0 0 14px rgba(30, 140, 255, 0.65) !important;
    }
    .hotspot.dragging-hs .hotspot-label { color: #1a8cff !important; } */

    /* ── Detail panel ─────────────────────────────────────────────── */
    #detail-panel {
      position: fixed;
      top: 0;
      left: 0;
      width: 365px;
      height: 100dvh;
      background: #faf9f6;
      border-right: 3px solid #1a1a1a;
      z-index: 1000;
      display: flex;
      flex-direction: column;
    }

    /* ── Logo area ────────────────────────────────────────────────── */
    #panel-logo-area {
      display: flex;
      flex-direction: row;
      align-items: center;
      padding: 20px 20px 20px 16px;
      border-bottom: 1px solid #1a1a1a;
      flex-shrink: 0;
    }
    #logo-wrap {
      position: relative;
      width: 198px;
      height: 198px;
      margin: 0 auto;
    }
    #logo-link {
      display: block;
      cursor: pointer;
      text-decoration: none;
      clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
    }
    #logo-img {
      display: block;
      width: 198px;
      height: 198px;
      object-fit: contain;
    }
    #logo-ring {
      position: absolute;
      inset: 28px;
      border: 4px solid transparent;
      border-radius: 2px;
      background: transparent;
      transform: rotate(45deg);
      transition: border-color 0.15s, box-shadow 0.15s;
      pointer-events: none;
    }
    #logo-wrap:hover #logo-ring {
      border-color: #1a1a1a;
      box-shadow: 0 0 6px rgba(0,0,0,0.20);
    }
    #location-image {
      display: none;
      width: 100%;
      max-height: 260px;
      object-fit: contain;
    }
    #detail-panel.has-location-image #logo-wrap    { display: none; }
    #detail-panel.has-location-image #location-image { display: block; }

    /* ── Language toggle (placeholder state — horizontal) ────────── */
    #lang-toggle {
      display: flex;
      flex-direction: row;
      justify-content: center;
      padding: 10px 20px;
      border-bottom: 1px solid #1a1a1a;
      flex-shrink: 0;
    }
    #detail-panel.has-location #lang-toggle { display: none; }

    /* ── Language toggle (header state) — own box, mirrors #lang-toggle */
    /* lives inside #panel-body — always flex; parent shows/hides */
    #lang-toggle-header {
      display: flex;
      flex-direction: row;
      justify-content: center;
      padding: 10px 20px;
      border-bottom: 1px solid #1a1a1a;
    }

    .lang-btn {
      background: none;
      border: 1px solid #1a1a1a;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.10em;
      cursor: pointer;
      padding: 5px 18px;
      color: #aaa;
      transition: background 0.15s, color 0.15s;
    }
    /* horizontal toggle: remove right border on EN */
    #lang-toggle .lang-btn:first-child { border-right: none; }
    /* horizontal toggle: remove right border on EN */
    #lang-toggle-header .lang-btn:first-child { border-right: none; }
    .lang-btn.active { background: #1a1a1a; color: #fff; }
    .lang-btn:hover:not(.active) { background: #f0ece6; color: #1a1a1a; }

    /* Hide non-active language content everywhere */
    body.lang-en [data-lang="de"] { display: none; }
    body.lang-de [data-lang="en"] { display: none; }

    /* ── Placeholder (no location selected) ───────────────────────── */
    #panel-placeholder {
      flex: 1;
      overflow-y: auto;
      padding: 20px 20px 10px;
      display: flex;
      flex-direction: column;
    }
    #placeholder-intro {
      font-size: 15px;
      font-style: italic;
      color: #c0b8b0;
      line-height: 1.6;
      text-align: center;
      margin-bottom: 14px;
    }
    .placeholder-section { margin-bottom: 18px; }
    .placeholder-section-label {
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: #bbb;
      margin-bottom: 5px;
    }
    .placeholder-text {
      font-size: 13px;
      line-height: 1.75;
      color: #444;
      white-space: pre-wrap;
    }
    .placeholder-text.empty {
      color: #ccc;
      font-style: italic;
    }

    /* ── GO button (lives inside #panel-placeholder) ──────────────── */
    #panel-go {
      margin-top: auto;
      padding: 14px 0 4px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0;
    }
    #btn-go {
      background: #1a1a1a;
      color: #fff;
      border: none;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      padding: 10px 40px;
      cursor: pointer;
      transition: background 0.15s;
    }
    #btn-go:hover { background: #444; }

    /* ── Location details (hidden until a location is selected) ───── */
    #panel-body   { display: none; }
    #panel-nav    { display: none; }

    #detail-panel.has-location #panel-placeholder { display: none; }
    #detail-panel.has-location #panel-body        { display: block; }
    #detail-panel.has-location #panel-nav         { display: flex; }

    /* header and toggle live inside #panel-body — always flex; parent shows/hides them */
    #panel-header {
      display: flex;
      align-items: flex-start;
      justify-content: space-between;
      padding: 18px 20px 14px;
      border-bottom: 1px solid #1a1a1a;
    }
    #panel-header > div:first-child { flex: 1; }
    #panel-number {
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: #aaa;
      margin-bottom: 3px;
    }
    #panel-title {
      font-size: 17px;
      font-weight: 700;
      color: #1a1a1a;
      line-height: 1.3;
    }
    #panel-close {
      background: none;
      border: none;
      font-size: 22px;
      line-height: 1;
      cursor: pointer;
      color: #bbb;
      padding: 0 0 0 12px;
      flex-shrink: 0;
      transition: color 0.1s;
    }
    #panel-close:hover { color: #333; }

    #panel-text-wrap {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #panel-scroll {
      flex: 1;
      min-height: 0;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }
    #panel-body {
      flex: 1;
      overflow-y: auto;
      padding: 0 0 10px;
    }
    .panel-lang-section { margin-top: 12px; padding: 0 20px; }
    .panel-lang-section + .panel-lang-section { margin-top: 14px; }
    .panel-lang-label {
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.10em;
      text-transform: uppercase;
      color: #bbb;
      margin-bottom: 4px;
    }
    .panel-summary {
      font-size: 13px;
      line-height: 1.75;
      color: #444;
      white-space: pre-wrap;
    }
    .panel-summary.empty {
      color: #ccc;
      font-style: italic;
    }

    /* Inline location cross-references like [•4] */
    .loc-ref {
      cursor: pointer;
      color: #E74111;
      text-decoration: underline;
      text-decoration-style: dotted;
      text-underline-offset: 2px;
      white-space: nowrap;
    }
    .loc-ref:hover { color: #b83610; }

    #panel-nav {
      gap: 24px;
      padding: 18px 20px;
      border-top: 1px solid #1a1a1a;
      flex-shrink: 0;
      justify-content: center;
    }
    .nav-btn-wrap {
      position: relative;
      flex: none;
    }
    .nav-btn-wrap::after {
      content: '';
      position: absolute;
      inset: 5px 6px 5px 4px;
      border: 3px solid transparent;
      border-radius: 2px;
      transform: rotate(45deg);
      transition: border-color 0.15s, box-shadow 0.15s;
      pointer-events: none;
    }
    .nav-btn-wrap:hover::after {
      border-color: #E74111;
      box-shadow: 0 0 6px rgba(231, 65, 17, 0.35);
    }
    .nav-btn-wrap:has(button:disabled) { opacity: 0.35; pointer-events: none; }
    .panel-nav-btn {
      width: 48px;
      height: 48px;
      background: #1a1a1a;
      border: none;
      clip-path: polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s;
    }
    .nav-btn-wrap:hover .panel-nav-btn { background: #333; }
    #btn-prev img { transform: translateX(-2px); }
    .panel-nav-btn img {
      width: 40px;
      height: 40px;
      object-fit: contain;
      display: block;
    }

    /* Edit banner + save status — disabled
    #edit-banner { ... }
    #save-status { ... } */

    /* ── Zoom controls ────────────────────────────────────────────── */
    #zoom-controls {
      position: fixed;
      bottom: 24px;
      right: 24px;
      display: flex;
      flex-direction: column;
      gap: 3px;
      z-index: 200;
    }
    .zoom-btn {
      width: 36px;
      height: 36px;
      background: rgba(255,255,255,0.88);
      border: 1px solid rgba(0,0,0,0.15);
      border-radius: 6px;
      font-size: 22px;
      line-height: 1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 2px 8px rgba(0,0,0,0.18);
      color: #333;
      transition: background 0.1s;
    }
    .zoom-btn:hover { background: #fff; }
    #zoom-buttons { display: flex; flex-direction: column; gap: 3px; }
    #btn-zoom-toggle { display: none; }
    #btn-zoom-location { display: none; margin-top: 5px; }
    #detail-panel.has-location ~ #zoom-controls #btn-zoom-location { display: flex; }

    /* Help hint — disabled
    #help-hint { ... } */

    /* ── Panel bottom strip ───────────────────────────────────────── */
    #panel-bottom { flex-shrink: 0; }

    /* ── Drag handle & sec-btn (mobile-only) ─────────────────────── */
    #panel-drag-handle { display: none; }
    .sec-btn { display: none; } /* hidden on desktop; shown in mobile block below */

    /* ── Mobile: bottom sheet, same flex-column as desktop ─────────── */
    @media (max-width: 768px) {
      /* Panel sits at the bottom; flex-column layout is inherited from base */
      #detail-panel {
        top: auto;
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        height: 67dvh;
        border-right: none;
        border-top: none;
        overflow: hidden;
      }

      /* Drag handle replaces the border-top — grab here to resize panel */
      #panel-drag-handle {
        display: block;
        height: 6px;
        background: #1a1a1a;
        cursor: ns-resize;
        flex-shrink: 0;
        touch-action: none;
      }

      /* Logo area: tighter padding, centred */
      #panel-logo-area {
        padding: 12px 16px;
        justify-content: center;
      }
      /* Location image fills edge-to-edge */
      #detail-panel.has-location-image #panel-logo-area { padding: 0; }

      /* Logo: 25vw diamond (quarter of screen width) */
      #logo-wrap {
        width: 25vw;
        height: 25vw;
        overflow: visible;
        flex-shrink: 0;
        margin: 0;
      }
      #logo-link { position: absolute; inset: 0; clip-path: none; }
      #logo-img  { width: 100%; height: 100%; object-fit: contain; }
      #logo-ring { inset: 14%; border-width: 2px; }

      /* Location image fills full panel width */
      #location-image { width: 100%; max-height: none; }

      /* Bottom strip: flex column, pinned to the bottom of the panel */
      #panel-bottom {
        display: flex;
        flex-direction: column;
        flex-shrink: 0;
        margin-top: auto;   /* pushes panel-bottom to the bottom regardless of what's above */
      }

      /* panel-scroll is the single scroll container on mobile */
      #panel-scroll { overflow-y: auto; overflow-x: hidden; }

      /* Children don't scroll independently — parent (#panel-scroll) handles it */
      #panel-placeholder,
      #panel-body { overflow-y: visible; flex: none; min-height: 0; }

      /* Header: compact padding */
      #panel-header { padding: 12px 14px 10px; }

      /* Zoom controls: horizontal row above the bottom panel */
      #zoom-controls {
        bottom: calc(67dvh + 12px);
        right: 16px;
        flex-direction: row;
        align-items: center;
      }
      /* Inner buttons: horizontal, collapsible via max-width */
      #zoom-buttons {
        flex-direction: row;
        max-width: 300px;
        overflow: hidden;
        transition: max-width 0.25s ease, opacity 0.2s ease;
      }
      #zoom-controls.zoom-collapsed #zoom-buttons {
        max-width: 0;
        opacity: 0;
        pointer-events: none;
      }
      #btn-zoom-toggle { display: flex; }
      /* No top margin needed in horizontal layout */
      #btn-zoom-location { margin-top: 0; }

      /* Nav row: always visible on mobile (overrides default display:none) */
      #panel-nav {
        display: flex;
        padding: 10px 20px;
        align-items: center;
        border-top: 1px solid #1a1a1a;
      }

      /* Sec-btn toggle buttons — shown in the nav row on mobile */
      .sec-btn {
        width: 44px;
        height: 44px;
        background: #d4cfc8;
        border: none;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        color: #888;
        flex-shrink: 0;
        transition: background 0.15s, color 0.15s;
      }
      .sec-btn:hover:not(.active) {
        background: #bfb9b1;
        color: #444;
      }
      .sec-btn.active {
        background: #1a1a1a;
        color: #fff;
      }

      /* Panel height transition */
      #detail-panel { transition: height 0.3s ease; }
      /* Skip height transition when index bar is toggled (bar itself is instant) */
      #detail-panel.height-instant { transition: none !important; }
      /* Map hidden: panel covers full screen */
      #detail-panel.map-hidden { height: 100dvh; }

      /* Text section (incl. logo/image): collapse the wrapper with max-height + fade.
         100dvh ensures no gap even when the panel is full-height (map hidden). */
      #panel-text-wrap {
        max-height: 100dvh;
        transition: max-height 0.3s ease, opacity 0.25s ease;
      }
      #detail-panel.hide-text #panel-text-wrap {
        max-height: 0;
        opacity: 0;
      }

    }
  </style>
</head>
<body class="lang-en">

<!-- Load screen — shown until places.json is opened -->
<div id="load-screen">
  <div id="load-card">
    <h1>Berlin Places Map</h1>
    <p>Open <code>places.json</code> to load location data.<br>
       You'll be able to view locations and edit coordinates.</p>
    <button id="load-btn">Open places.json</button>
    <div id="load-error">Could not open file. Please try again.</div>
  </div>
</div>

<div id="map-viewport">
  <div id="map-wrapper">
    <img id="map-image" src="assets/places_map_upscaled.png" alt="Berlin Places Map" draggable="false">
    <div id="ch-left"></div>
    <div id="ch-right"></div>
    <div id="cv-top"></div>
    <div id="cv-bottom"></div>
    <!-- hotspot divs injected by JS -->
  </div>
</div>

<!-- <div id="edit-banner"></div> -->
<!-- <div id="save-status"></div> -->

<div id="detail-panel">
  <div id="panel-drag-handle"></div>
  <div id="panel-text-wrap">
    <div id="panel-scroll">
      <div id="panel-logo-area">
        <div id="logo-wrap">
          <a id="logo-link" href="https://www.ventil-verlag.de/titel/1919/places" target="_blank" rel="noopener">
            <img id="logo-img" src="assets/diamond_logo.png" alt="Places">
          </a>
          <div id="logo-ring"></div>
        </div>
        <img id="location-image" src="" alt="">
      </div>
      <div id="lang-toggle">
        <button class="lang-btn active" id="lang-en-btn">EN</button>
        <button class="lang-btn"        id="lang-de-btn">DE</button>
      </div>
      <div id="panel-placeholder">
      <div class="placeholder-section">
        <div class="placeholder-section-label" data-lang="en">About the Book</div>
        <div class="placeholder-section-label" data-lang="de">Über das Buch</div>
        <div id="about-book-en" class="placeholder-text" data-lang="en"></div>
        <div id="about-book-de" class="placeholder-text" data-lang="de"></div>
      </div>
      <div class="placeholder-section">
        <div class="placeholder-section-label" data-lang="en">Authors</div>
        <div class="placeholder-section-label" data-lang="de">Autoren</div>
        <div id="authors-en" class="placeholder-text" data-lang="en"></div>
        <div id="authors-de" class="placeholder-text" data-lang="de"></div>
      </div>
      <div id="panel-go">
        <p id="placeholder-intro">
          <span data-lang="en">explore places of Berlin's past</span>
          <span data-lang="de">erkunde Orte aus Berlins Vergangenheit</span>
        </p>
        <button id="btn-go">GO</button>
      </div>
    </div>
    <div id="panel-body">
      <div id="panel-header">
        <div>
          <div id="panel-number"></div>
          <div id="panel-title"></div>
        </div>
        <button id="panel-close" aria-label="Close">×</button>
      </div>
      <div id="lang-toggle-header">
        <button class="lang-btn active" id="lang-en-btn-h">EN</button>
        <button class="lang-btn"        id="lang-de-btn-h">DE</button>
      </div>
      <div class="panel-lang-section" data-lang="en">
        <div id="panel-summary-en" class="panel-summary"></div>
      </div>
      <div class="panel-lang-section" data-lang="de">
        <div id="panel-summary-de" class="panel-summary"></div>
      </div>
    </div>
    </div><!-- /#panel-scroll -->
  </div><!-- /#panel-text-wrap -->
  <div id="panel-bottom">
    <div id="panel-nav">
      <div class="nav-btn-wrap"><button class="panel-nav-btn" id="btn-prev" aria-label="Previous" disabled><img src="assets/arrow_left.png" alt=""></button></div>
      <button class="sec-btn active" id="sec-btn-map" title="Toggle map view">
        <svg width="16" height="16" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round">
          <path d="M1 11 L4.5 5 L7.5 9 L10 6.5 L13 11 Z"/>
        </svg>
      </button>
      <button class="sec-btn active" id="sec-btn-txt" title="Toggle text">
        <svg width="16" height="16" viewBox="0 0 14 14" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round">
          <line x1="2" y1="4" x2="12" y2="4"/>
          <line x1="2" y1="7" x2="12" y2="7"/>
          <line x1="2" y1="10" x2="9" y2="10"/>
        </svg>
      </button>
      <div class="nav-btn-wrap"><button class="panel-nav-btn" id="btn-next" aria-label="Next" disabled><img src="assets/arrow_right.png" alt=""></button></div>
    </div>
  </div><!-- /#panel-bottom -->
</div>

<div id="zoom-controls">
  <div id="zoom-buttons">
    <button class="zoom-btn" id="btn-zoom-in"  title="Zoom in">+</button>
    <button class="zoom-btn" id="btn-zoom-out" title="Zoom out">−</button>
    <button class="zoom-btn" id="btn-zoom-location" title="Go to selected location">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
        <circle cx="8" cy="8" r="5.5"/>
        <circle cx="8" cy="8" r="1.5" fill="currentColor" stroke="none"/>
        <line x1="8" y1="1" x2="8" y2="3.5"/>
        <line x1="8" y1="12.5" x2="8" y2="15"/>
        <line x1="1" y1="8" x2="3.5" y2="8"/>
        <line x1="12.5" y1="8" x2="15" y2="8"/>
      </svg>
    </button>
    <button class="zoom-btn" id="btn-zoom-fit" title="Fit full map">
      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="1,5 1,1 5,1"/>
        <polyline points="11,1 15,1 15,5"/>
        <polyline points="15,11 15,15 11,15"/>
        <polyline points="5,15 1,15 1,11"/>
      </svg>
    </button>
  </div>
  <button class="zoom-btn" id="btn-zoom-toggle" title="Hide zoom controls">×</button>
</div>

<!-- <div id="help-hint">Scroll to zoom · drag to pan</div> -->

<script>
'use strict';

// ══════════════════════════════════════════════════════════════════════
//  State
// ══════════════════════════════════════════════════════════════════════
let places = {};          // loaded from places.json → data.locations
let bookData = {};        // full parsed JSON (locations, authors, about_the_book)
let lang = 'en';          // active language: 'en' | 'de'
let fileHandle = null;    // FileSystemFileHandle — enables auto-save

let scale = 1, tx = 0, ty = 0;
let isDragging = false, hasDragged = false;
let dragStartX = 0, dragStartY = 0, dragOriginTx = 0, dragOriginTy = 0;
// let editMode = false;
// let draggingHotspotId = null;
// let draggingHotspotEl = null;
let lastTouchDist = 0;
// let saveStatusTimer = null;
let activeId = null;     // currently open panel location
let linkedGroup = new Set(); // IDs linked via bracket reference (source + targets)

// Track breakpoint for resize fit-full-map trigger
let prevIsMobile = window.innerWidth <= 768;

// Mobile section toggle state
let mobileMapOn = true;   // true = map visible; false = panel covers full screen
let mobileTxtOn = true;
let zoomExpanded = true;  // mobile: zoom controls visible
let autoZoom     = true;  // zoom to location on navigation; toggled by fit/zoom buttons
let panelH = 0;           // stored panel height in px (draggable; init'd at image load)

let MIN_SCALE = 0.05;
let MAX_SCALE = 10;
let imgW = 0, imgH = 0;
let HOTSPOT_HALF = 18; // half of .hotspot width (36px), overwritten in updateHotspotVars()
let BORDER_SIZE  = 3;  // crosshair line thickness in image-space px, same

function getPanelW() { return window.innerWidth > 768 ? 365 : 0; }
function getPanelH() { return window.innerWidth <= 768 ? document.getElementById('detail-panel').offsetHeight : 0; }

// ══════════════════════════════════════════════════════════════════════
//  DOM refs
// ══════════════════════════════════════════════════════════════════════
const viewport    = document.getElementById('map-viewport');
const wrapper     = document.getElementById('map-wrapper');
const mapImage    = document.getElementById('map-image');
const detailPanel = document.getElementById('detail-panel');
// const editBanner  = document.getElementById('edit-banner');
// const saveStatus  = document.getElementById('save-status');
const loadScreen  = document.getElementById('load-screen');
const loadError   = document.getElementById('load-error');

// ══════════════════════════════════════════════════════════════════════
//  Auto-fetch places.json from the same directory
// ══════════════════════════════════════════════════════════════════════
function initPlaces(data) {
  bookData = data;
  if (Array.isArray(data.locations)) {
    places = {};
    data.locations.forEach(loc => { places[String(loc.id)] = loc; });
  } else {
    places = data.locations || data;
  }
  populatePlaceholderContent();
  loadScreen.classList.add('hidden');
  if (imgW > 0) buildHotspots();
}

fetch('places.json')
  .then(r => r.json())
  .then(initPlaces)
  .catch(() => { /* fetch unavailable (e.g. file://) — fall through to manual picker */ });

// ══════════════════════════════════════════════════════════════════════
//  File I/O — uses File System Access API for read + write
// ══════════════════════════════════════════════════════════════════════
document.getElementById('load-btn').addEventListener('click', async () => {
  if (!window.showOpenFilePicker) {
    loadError.textContent = 'Your browser does not support the File System Access API. Use Chrome, Edge, or Safari 17+.';
    loadError.classList.add('visible');
    return;
  }
  try {
    [fileHandle] = await window.showOpenFilePicker({
      types: [{ description: 'JSON', accept: { 'application/json': ['.json'] } }],
      multiple: false,
    });
    const file = await fileHandle.getFile();
    const data = JSON.parse(await file.text());
    bookData = data;
    if (Array.isArray(data.locations)) {
      places = {};
      data.locations.forEach(loc => { places[String(loc.id)] = loc; });
    } else {
      places = data.locations || data;
    }
    populatePlaceholderContent();
    loadError.classList.remove('visible');
    loadScreen.classList.add('hidden');
    if (imgW > 0) buildHotspots(); // image already loaded
  } catch (err) {
    if (err.name === 'AbortError') return; // user cancelled picker
    console.error('Load error:', err);
    loadError.textContent = 'Failed to read file: ' + err.message;
    loadError.classList.add('visible');
  }
});

/* Edit/save functions — disabled
async function saveJson() { ... }
function showSaveStatus(text, fade) { ... }
*/

// ══════════════════════════════════════════════════════════════════════
//  Transform helpers
// ══════════════════════════════════════════════════════════════════════
function clampPan() {
  const PANEL_W = getPanelW();
  const PANEL_H = getPanelH();
  const availW  = window.innerWidth  - PANEL_W;
  const availH  = window.innerHeight - PANEL_H;
  if (imgW * scale <= availW) {
    tx = PANEL_W + (availW - imgW * scale) / 2;
  } else {
    tx = Math.max(window.innerWidth - imgW * scale, Math.min(PANEL_W, tx));
  }
  if (imgH * scale <= availH) {
    ty = (availH - imgH * scale) / 2;
  } else {
    ty = Math.max(availH - imgH * scale, Math.min(0, ty));
  }
}

function applyTransform() {
  clampPan();
  wrapper.style.transform = `translate(${tx}px,${ty}px) scale(${scale})`;
}

// Hotspot size at fit zoom = sqrt(map area height) screen-px, scales with zoom.
function updateHotspotVars() {
  const mapH      = window.innerHeight - getPanelH();
  const targetPx  = Math.sqrt(mapH) - mapH**(1/5);
  const naturalPx = Math.round(targetPx / MIN_SCALE);
  HOTSPOT_HALF = naturalPx / 2;
  BORDER_SIZE  = Math.round(targetPx * (3 / 30) / MIN_SCALE);
  document.documentElement.style.setProperty('--hs-size',   naturalPx + 'px');
  document.documentElement.style.setProperty('--hs-inset',  Math.round(targetPx * (5 / 30) / MIN_SCALE) + 'px');
  document.documentElement.style.setProperty('--hs-border', BORDER_SIZE + 'px');
}

function zoomAt(factor, cx, cy) {
  const newScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * factor));
  if (newScale === scale) return;
  const imgX = (cx - tx) / scale;
  const imgY = (cy - ty) / scale;
  tx = cx - imgX * newScale;
  ty = cy - imgY * newScale;
  scale = newScale;
  applyTransform();
}

// ══════════════════════════════════════════════════════════════════════
//  Hotspot rendering
// ══════════════════════════════════════════════════════════════════════
function buildHotspots() {
  // Remove any existing hotspots before re-building
  document.querySelectorAll('.hotspot').forEach(h => h.remove());

  Object.entries(places).forEach(([id, place]) => {
    const el = document.createElement('div');
    el.className = 'hotspot';
    el.dataset.id = id;
    el.style.left = (place.relative_map_position.x * imgW) + 'px';
    el.style.top  = (place.relative_map_position.y * imgH) + 'px';
    el.innerHTML  = `<div class="hotspot-ring"></div><div class="hotspot-label">${id}</div>`;

    /* edit mousedown — disabled
    el.addEventListener('mousedown', e => { ... }); */

    el.addEventListener('click', e => {
      // if (editMode) { e.stopPropagation(); return; }
      if (hasDragged) return;
      e.stopPropagation();
      openPanel(id);
    });

    wrapper.appendChild(el);
  });

  applyTransform();
}


/* Edit mode banner function — disabled
function updateEditBanner() { ... }
*/


// ══════════════════════════════════════════════════════════════════════
//  Modal
// ══════════════════════════════════════════════════════════════════════
function sortedPlaceIds() {
  return Object.keys(places).map(Number).sort((a, b) => a - b).map(String);
}

function openPanel(id) {
  // Clear linked group unless this location is a member of it
  if (!linkedGroup.has(id)) linkedGroup.clear();

  const place = places[id];
  activeId = id;

  document.getElementById('panel-number').textContent = `Location ${id}`;
  document.getElementById('panel-title').textContent  = place.name || '(unnamed)';

  const enEl = document.getElementById('panel-summary-en');
  const deEl = document.getElementById('panel-summary-de');

  const textEn = place.description_en || place.summary_en || '';
  const textDe = place.description_de || place.summary_de || '';
  enEl.innerHTML = textEn ? md(textEn) : '(no English summary yet)';
  enEl.classList.toggle('empty', !textEn);

  deEl.innerHTML = textDe ? md(textDe) : '(noch keine deutsche Beschreibung)';
  deEl.classList.toggle('empty', !textDe);

  const ids = sortedPlaceIds();
  const idx = ids.indexOf(id);
  document.getElementById('btn-prev').disabled = idx <= 0;
  document.getElementById('btn-next').disabled = idx >= ids.length - 1;

  document.querySelectorAll('.hotspot.active').forEach(h => h.classList.remove('active'));
  const activeEl = wrapper.querySelector(`.hotspot[data-id="${id}"]`);
  if (activeEl) activeEl.classList.add('active');

  const cx  = place.relative_map_position.x * imgW;
  const cy  = place.relative_map_position.y * imgH;
  const gap = HOTSPOT_HALF;
  const bh  = BORDER_SIZE / 2; // offset so border centre aligns with (cx, cy)

  const chL = document.getElementById('ch-left');
  const chR = document.getElementById('ch-right');
  const cvT = document.getElementById('cv-top');
  const cvB = document.getElementById('cv-bottom');

  chL.style.top   = (cy - bh) + 'px';
  chL.style.width = Math.max(0, cx - gap) + 'px';
  chR.style.top   = (cy - bh) + 'px';
  chR.style.left  = (cx + gap) + 'px';

  cvT.style.left   = (cx - bh) + 'px';
  cvT.style.height = Math.max(0, cy - gap) + 'px';
  cvB.style.left   = (cx - bh) + 'px';
  cvB.style.top    = (cy + gap) + 'px';

  [chL, chR, cvT, cvB].forEach(el => el.style.display = 'block');

  const locImg = document.getElementById('location-image');
  if (place.image) {
    locImg.src = place.image;
    locImg.alt = place.name || '';
    detailPanel.classList.add('has-location-image');
  } else {
    locImg.src = '';
    detailPanel.classList.remove('has-location-image');
  }

  document.getElementById('panel-scroll').scrollTop = 0;
  document.getElementById('panel-body').scrollTop = 0;
  if (autoZoom) {
    zoomToActive();
  } else {
    ensureInView(id);
  }
  applyLinkedGroup();
  detailPanel.classList.add('has-location');

}

function ensureInView(id) {
  const place = places[id];
  if (!place) return;

  const PANEL_W = getPanelW();
  const PANEL_H = getPanelH();
  const availW  = window.innerWidth  - PANEL_W;
  const availH  = window.innerHeight - PANEL_H;
  const MARGIN  = 60; // screen-px clearance from edges

  const screenX = place.relative_map_position.x * imgW * scale + tx;
  const screenY = place.relative_map_position.y * imgH * scale + ty;

  const inView =
    screenX >= PANEL_W + MARGIN &&
    screenX <= window.innerWidth - MARGIN &&
    screenY >= MARGIN &&
    screenY <= availH - MARGIN;

  if (inView) return;

  // Pan to center it — use centerOnActive so clampPan doesn't fight the position
  centerOnActive(true);
}

function fitGroupInView() {
  const ids = [...linkedGroup];
  if (ids.length === 0) return;

  const PANEL_W = getPanelW();
  const PANEL_H = getPanelH();
  const availW  = window.innerWidth  - PANEL_W;
  const availH  = window.innerHeight - PANEL_H;
  const PAD     = 60; // screen-px margin around the bounding box

  const locs = ids.map(id => places[id]).filter(Boolean);
  if (locs.length === 0) return;

  // Bounding box in image-space px, expanded by hotspot half-size
  const HS   = HOTSPOT_HALF;
  const minX = Math.min(...locs.map(p => p.relative_map_position.x * imgW)) - HS;
  const maxX = Math.max(...locs.map(p => p.relative_map_position.x * imgW)) + HS;
  const minY = Math.min(...locs.map(p => p.relative_map_position.y * imgH)) - HS;
  const maxY = Math.max(...locs.map(p => p.relative_map_position.y * imgH)) + HS;

  const bboxW = maxX - minX;
  const bboxH = maxY - minY;

  // Scale to fit bbox into viewport with padding
  let targetScale = Math.min(
    (availW - PAD * 2) / bboxW,
    (availH - PAD * 2) / bboxH
  );
  targetScale = Math.min(targetScale, scale); // never zoom in, only zoom out if needed
  targetScale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, targetScale));

  // Center bbox in the available area
  const imgCX = (minX + maxX) / 2;
  const imgCY = (minY + maxY) / 2;
  scale = targetScale;
  tx    = PANEL_W + availW / 2 - imgCX * scale;
  ty    = availH  / 2          - imgCY * scale;

  wrapper.style.transition = 'transform 0.45s ease';
  applyTransform();
  setTimeout(() => { wrapper.style.transition = ''; }, 450);
}

function applyLinkedGroup() {
  document.querySelectorAll('.hotspot.linked, .hotspot.highlighted').forEach(h => {
    h.classList.remove('linked');
    h.classList.remove('highlighted');
  });
  linkedGroup.forEach(id => {
    const hs = wrapper.querySelector(`.hotspot[data-id="${id}"]`);
    if (hs) hs.classList.add('linked');
  });
}

function closePanel() {
  linkedGroup.clear();
  detailPanel.classList.remove('has-location');
  detailPanel.classList.remove('has-location-image');
  document.getElementById('location-image').src = '';
  document.querySelectorAll('.hotspot').forEach(h => {
    h.classList.remove('active');
    h.classList.remove('linked');
    h.classList.remove('highlighted');
  });
  ['ch-left','ch-right','cv-top','cv-bottom'].forEach(id =>
    document.getElementById(id).style.display = 'none');
  activeId = null;
  document.getElementById('panel-scroll').scrollTop = 0;
  document.getElementById('btn-prev').disabled = true;
  document.getElementById('btn-next').disabled = true;
}

// ══════════════════════════════════════════════════════════════════════
//  Map positioning helpers
// ══════════════════════════════════════════════════════════════════════

// Centre the active location in the visible map area at the current scale.
// Goes through applyTransform so clampPan enforces the same map boundaries
// as free panning — no whitespace shown at the map edges.
function centerOnActive(animate) {
  if (!activeId || !places[activeId]) return;
  const place  = places[activeId];
  const PANEL_W = getPanelW();
  const PANEL_H = getPanelH();
  const availW  = window.innerWidth  - PANEL_W;
  const availH  = window.innerHeight - PANEL_H;
  tx = PANEL_W + availW / 2 - place.relative_map_position.x * imgW * scale;
  ty = availH  / 2          - place.relative_map_position.y * imgH * scale;
  if (animate) {
    wrapper.style.transition = 'transform 0.45s ease';
    applyTransform();
    setTimeout(() => { wrapper.style.transition = ''; }, 450);
  } else {
    applyTransform();
  }
}

function zoomToActive() {
  if (!activeId || !places[activeId]) return;
  const zoomFactor = window.innerWidth <= 768 ? 4 : 2.5;
  if (window.innerWidth <= 768) {
    const refAvailH  = window.innerHeight * 0.33;
    const refMinScale = Math.min(window.innerWidth / imgW, refAvailH / imgH);
    scale = refMinScale * zoomFactor;
  } else {
    scale = MIN_SCALE * zoomFactor;
  }
  MAX_SCALE = Math.max(MAX_SCALE, scale);
  centerOnActive(true);
}

// Fit-full-map helper (recalculates MIN_SCALE for current panel size)
function fitMap(animate) {
  const PANEL_W = getPanelW();
  const PANEL_H = getPanelH();
  const availW  = window.innerWidth  - PANEL_W;
  const availH  = window.innerHeight - PANEL_H;
  MIN_SCALE = Math.min(availW / imgW, availH / imgH);
  MAX_SCALE = MIN_SCALE * 5;
  scale = MIN_SCALE;
  tx = PANEL_W + (availW - imgW * scale) / 2;
  ty = (availH  - imgH * scale) / 2;
  if (animate) {
    wrapper.style.transition = 'transform 0.35s ease';
    applyTransform();
    setTimeout(() => { wrapper.style.transition = ''; }, 370);
  } else {
    applyTransform();
  }
}

// ══════════════════════════════════════════════════════════════════════
//  Mobile section toggles
// ══════════════════════════════════════════════════════════════════════
function applyMobileToggles() {
  if (window.innerWidth > 768) return;

  // Map: hidden = panel covers full screen
  detailPanel.classList.toggle('map-hidden', !mobileMapOn);
  document.getElementById('sec-btn-map').classList.toggle('active', mobileMapOn);

  // Text: animate text-wrap (logo + image + text) in/out via max-height
  detailPanel.classList.toggle('hide-text', !mobileTxtOn);
  document.getElementById('sec-btn-txt').classList.toggle('active', mobileTxtOn);

  // Panel height: managed via inline style so drag + toggles stay in sync
  if (!mobileMapOn) {
    detailPanel.style.height = '100dvh';
  } else if (!mobileTxtOn) {
    // Collapse to drag handle + the entire bottom strip
    const stripH = document.getElementById('panel-drag-handle').offsetHeight
                 + document.getElementById('panel-bottom').offsetHeight;
    detailPanel.style.height = stripH + 'px';
  } else {
    detailPanel.style.height = panelH + 'px';
  }

  // Zoom controls: hide when map is fully covered
  const zc = document.getElementById('zoom-controls');
  if (!mobileMapOn) {
    zc.style.display = 'none';
  } else {
    zc.style.display = '';
  }

  // After CSS transitions settle: fit map (if text hidden) or re-centre
  const hidingText = !mobileTxtOn && mobileMapOn;
  setTimeout(() => {
    zc.style.bottom = (detailPanel.offsetHeight + 12) + 'px';
    if (hidingText) {
      fitMap(true);
    } else {
      applyTransform();
    }
  }, 350);
}

function md(text) {
  return text
    .replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\[(\d+(?:,\s*\d+)*)\]/g, (_, raw) => {
      const ids = raw.split(',').map(s => s.trim()).filter(Boolean);
      return `<span class="loc-ref" data-ids="${ids.join(',')}">[${ids.join(', ')}]</span>`;
    })
    .replace(/\n/g, '<br>');
}

function populatePlaceholderContent() {
  const ab = bookData.about_the_book || {};
  const au = bookData.authors || {};
  const setEl = (id, text, fallback) => {
    const el = document.getElementById(id);
    el.innerHTML = text ? md(text) : fallback;
    el.classList.toggle('empty', !text);
  };
  setEl('about-book-en', ab.summary_en, '(no English summary yet)');
  setEl('about-book-de', ab.summary_de, '(noch keine deutsche Beschreibung)');
  setEl('authors-en',    au.summary_en, '(no English author info yet)');
  setEl('authors-de',    au.summary_de, '(noch keine deutschen Autoreninfos)');
}

document.getElementById('panel-close').addEventListener('click', closePanel);

// ── Location cross-reference links inside panel text ──────────────────
detailPanel.addEventListener('click', e => {
  const ref = e.target.closest('.loc-ref');
  if (!ref) return;
  const targetIds = ref.dataset.ids.split(',');
  // Set linked group: source location + all targets
  linkedGroup = new Set([activeId, ...targetIds].filter(Boolean));
  if (targetIds[0]) openPanel(targetIds[0]);
  fitGroupInView();
});
detailPanel.addEventListener('mouseover', e => {
  const ref = e.target.closest('.loc-ref');
  if (!ref) return;
  ref.dataset.ids.split(',').forEach(id => {
    if (!linkedGroup.has(id)) {
      const hs = wrapper.querySelector(`.hotspot[data-id="${id}"]`);
      if (hs) hs.classList.add('highlighted');
    }
  });
});
detailPanel.addEventListener('mouseout', e => {
  const ref = e.target.closest('.loc-ref');
  if (!ref) return;
  document.querySelectorAll('.hotspot.highlighted').forEach(h => {
    if (!linkedGroup.has(h.dataset.id)) h.classList.remove('highlighted');
  });
});

function setLang(l) {
  lang = l;
  document.body.className = 'lang-' + l;
  document.getElementById('btn-go').textContent = l === 'en' ? 'GO' : 'LOS';
  ['', '-h'].forEach(suffix => {
    document.getElementById('lang-en-btn' + suffix).classList.toggle('active', l === 'en');
    document.getElementById('lang-de-btn' + suffix).classList.toggle('active', l === 'de');
  });
}
document.getElementById('lang-en-btn').addEventListener('click', () => setLang('en'));
document.getElementById('lang-de-btn').addEventListener('click', () => setLang('de'));
document.getElementById('lang-en-btn-h').addEventListener('click', () => setLang('en'));
document.getElementById('lang-de-btn-h').addEventListener('click', () => setLang('de'));

document.getElementById('btn-go').addEventListener('click', () => {
  linkedGroup.clear();
  const ids = sortedPlaceIds();
  if (ids.length > 0) openPanel(ids[0]);
});
document.getElementById('btn-prev').addEventListener('click', () => {
  const ids = sortedPlaceIds();
  const idx = ids.indexOf(activeId);
  if (idx > 0) openPanel(ids[idx - 1]);
});
document.getElementById('btn-next').addEventListener('click', () => {
  const ids = sortedPlaceIds();
  const idx = ids.indexOf(activeId);
  if (idx < ids.length - 1) openPanel(ids[idx + 1]);
});

document.getElementById('sec-btn-map').addEventListener('click', () => {
  mobileMapOn = !mobileMapOn;
  applyMobileToggles();
});
document.getElementById('sec-btn-txt').addEventListener('click', () => {
  mobileTxtOn = !mobileTxtOn;
  applyMobileToggles();
});


// ── Panel drag-to-resize (mobile only) ────────────────────────────────
(function () {
  const handle = document.getElementById('panel-drag-handle');
  let resizeStartY = 0, resizeStartH = 0, resizeStartRatio = 1, resizeStartScale = 0;
  const MIN_PANEL_H = () =>
    handle.offsetHeight + document.getElementById('panel-bottom').offsetHeight + 40;
  const MAX_PANEL_H = () => Math.round(window.innerHeight * 0.92);

  function onMove(clientY) {
    const delta = resizeStartY - clientY;          // drag up → bigger panel
    panelH = Math.max(MIN_PANEL_H(), Math.min(MAX_PANEL_H(), resizeStartH + delta));
    detailPanel.style.height = panelH + 'px';
    const zc = document.getElementById('zoom-controls');
    zc.style.bottom = (panelH + 12) + 'px';

    // Always keep MIN_SCALE current for the new available area
    const PANEL_W = getPanelW();
    const availW  = window.innerWidth  - PANEL_W;
    const availH  = window.innerHeight - panelH;
    MIN_SCALE = Math.min(availW / imgW, availH / imgH);
    // MAX_SCALE must not drop below the drag-start scale (would cap and cause zoom-out)
    MAX_SCALE = Math.max(MIN_SCALE * 5, resizeStartScale);

    if (activeId && places[activeId]) {
      // Preserve zoom ratio from drag start, but never decrease below drag-start scale
      scale = Math.min(MAX_SCALE, Math.max(resizeStartScale, MIN_SCALE * resizeStartRatio));
      const pos = places[activeId].relative_map_position;
      tx = PANEL_W + availW / 2 - pos.x * imgW * scale;
      ty = availH  / 2          - pos.y * imgH * scale;
    } else {
      // No location — refit map to fill available area
      scale = MIN_SCALE;
      tx = PANEL_W + (availW - imgW * scale) / 2;
      ty = (availH  - imgH * scale) / 2;
    }
    applyTransform(); // clampPan enforces the same map boundaries as free panning
  }

  function onEnd() {
    detailPanel.style.transition = '';
    document.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup',   onEnd);
    document.removeEventListener('touchmove', onTouchMove);
    document.removeEventListener('touchend',  onEnd);
  }

  function onMouseMove(e) { onMove(e.clientY); }
  function onTouchMove(e) { e.preventDefault(); onMove(e.touches[0].clientY); }

  handle.addEventListener('mousedown', e => {
    if (window.innerWidth > 768 || !mobileTxtOn || !mobileMapOn) return;
    e.preventDefault();
    resizeStartY = e.clientY;
    resizeStartH = detailPanel.offsetHeight;
    resizeStartRatio = MIN_SCALE > 0 ? scale / MIN_SCALE : 1;
    resizeStartScale = scale;
    detailPanel.style.transition = 'none';
    wrapper.style.transition = '';   // cancel any in-progress map animation
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup',   onEnd);
  });

  handle.addEventListener('touchstart', e => {
    if (window.innerWidth > 768 || !mobileTxtOn || !mobileMapOn) return;
    e.preventDefault();
    resizeStartY = e.touches[0].clientY;
    resizeStartH = detailPanel.offsetHeight;
    resizeStartRatio = MIN_SCALE > 0 ? scale / MIN_SCALE : 1;
    resizeStartScale = scale;
    detailPanel.style.transition = 'none';
    wrapper.style.transition = '';   // cancel any in-progress map animation
    document.addEventListener('touchmove', onTouchMove, { passive: false });
    document.addEventListener('touchend',  onEnd);
  }, { passive: false });
}());

// ══════════════════════════════════════════════════════════════════════
//  Mouse — pan
// ══════════════════════════════════════════════════════════════════════
viewport.addEventListener('mousedown', e => {
  if (e.button !== 0) return;
  isDragging   = true;
  hasDragged   = false;
  dragStartX   = e.clientX;
  dragStartY   = e.clientY;
  dragOriginTx = tx;
  dragOriginTy = ty;
  viewport.classList.add('grabbing');
  e.preventDefault();
});

window.addEventListener('mousemove', e => {
  /* edit drag mousemove — disabled
  if (draggingHotspotId !== null) { ... return; } */
  if (!isDragging) return;
  const dx = e.clientX - dragStartX;
  const dy = e.clientY - dragStartY;
  if (Math.abs(dx) + Math.abs(dy) > 4) hasDragged = true;
  tx = dragOriginTx + dx;
  ty = dragOriginTy + dy;
  applyTransform();
});

window.addEventListener('mouseup', e => {
  /* edit drag mouseup — disabled
  if (draggingHotspotId !== null) { ... } */
  isDragging = false;
  viewport.classList.remove('grabbing');
});

// ══════════════════════════════════════════════════════════════════════
//  Mouse wheel — zoom
// ══════════════════════════════════════════════════════════════════════
viewport.addEventListener('dblclick', e => {
  if (!e.target.closest('.hotspot')) closePanel();
});

viewport.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = viewport.getBoundingClientRect();
  zoomAt(e.deltaY < 0 ? 1.12 : 1 / 1.12, e.clientX - rect.left, e.clientY - rect.top);
}, { passive: false });

document.getElementById('btn-zoom-in').addEventListener('click',  () =>
  zoomAt(1.3, (window.innerWidth + 360) / 2, window.innerHeight / 2));
document.getElementById('btn-zoom-out').addEventListener('click', () =>
  zoomAt(1 / 1.3, (window.innerWidth + 360) / 2, window.innerHeight / 2));

document.getElementById('btn-zoom-location').addEventListener('click', () => {
  autoZoom = true;
  zoomToActive();
});

document.getElementById('btn-zoom-fit').addEventListener('click', () => {
  autoZoom = false;
  fitMap(true);
});

document.getElementById('btn-zoom-toggle').addEventListener('click', () => {
  zoomExpanded = !zoomExpanded;
  const zc = document.getElementById('zoom-controls');
  const tb = document.getElementById('btn-zoom-toggle');
  zc.classList.toggle('zoom-collapsed', !zoomExpanded);
  tb.textContent = zoomExpanded ? '×' : '≡';
  tb.title = zoomExpanded ? 'Hide zoom controls' : 'Show zoom controls';
});

// ══════════════════════════════════════════════════════════════════════
//  Touch — pan + pinch zoom
// ══════════════════════════════════════════════════════════════════════
viewport.addEventListener('touchstart', e => {
  e.preventDefault();
  hasDragged = false;
  if (e.touches.length === 1) {
    isDragging   = true;
    dragStartX   = e.touches[0].clientX;
    dragStartY   = e.touches[0].clientY;
    dragOriginTx = tx;
    dragOriginTy = ty;
  } else if (e.touches.length === 2) {
    isDragging    = false;
    const t0 = e.touches[0], t1 = e.touches[1];
    lastTouchDist = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
  }
}, { passive: false });

viewport.addEventListener('touchmove', e => {
  e.preventDefault();
  const rect = viewport.getBoundingClientRect();
  if (e.touches.length === 1 && isDragging) {
    const dx = e.touches[0].clientX - dragStartX;
    const dy = e.touches[0].clientY - dragStartY;
    if (Math.abs(dx) + Math.abs(dy) > 4) hasDragged = true;
    tx = dragOriginTx + dx;
    ty = dragOriginTy + dy;
    applyTransform();
  } else if (e.touches.length === 2) {
    const t0 = e.touches[0], t1 = e.touches[1];
    const dist = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
    const cx   = (t0.clientX + t1.clientX) / 2 - rect.left;
    const cy   = (t0.clientY + t1.clientY) / 2 - rect.top;
    if (lastTouchDist > 0) zoomAt(dist / lastTouchDist, cx, cy);
    lastTouchDist = dist;
  }
}, { passive: false });

viewport.addEventListener('touchend', e => {
  if (e.touches.length === 0) isDragging = false;
}, { passive: false });

window.addEventListener('resize', () => {
  if (imgW === 0) return;
  const isMobile          = window.innerWidth <= 768;
  const crossedBreakpoint = isMobile !== prevIsMobile;
  prevIsMobile = isMobile;

  if (crossedBreakpoint) {
    // getPanelH() reads offsetHeight which is still at the old layout value
    // while the CSS media-query transition runs — use the expected dimensions instead.
    if (isMobile && panelH === 0) panelH = Math.round(window.innerHeight * 0.67);
    const zc = document.getElementById('zoom-controls');
    if (isMobile) {
      detailPanel.style.height = panelH + 'px';
      zc.style.bottom  = (panelH + 12) + 'px';  // position above panel
      zc.style.display = '';                      // clear any prior hidden state
    } else {
      detailPanel.style.height = '';  // let CSS (100dvh) take over on desktop
      zc.style.bottom  = '';          // let CSS (bottom: 24px) take over on desktop
      zc.style.display = '';
    }
    const pW = isMobile ? 0 : 365;
    const pH = isMobile ? panelH : 0;
    const aW = window.innerWidth  - pW;
    const aH = window.innerHeight - pH;
    MIN_SCALE = Math.min(aW / imgW, aH / imgH);
    MAX_SCALE = MIN_SCALE * 5;
    updateHotspotVars();  // recalibrate base size for the new layout
    scale = MIN_SCALE;
    tx = pW + (aW - imgW * scale) / 2;
    ty = (aH - imgH * scale) / 2;
  } else {
    const PANEL_W     = getPanelW();
    const PANEL_H     = getPanelH();
    const availW      = window.innerWidth  - PANEL_W;
    const availH      = window.innerHeight - PANEL_H;
    const newFitScale = Math.min(availW / imgW, availH / imgH);
    const oldMinScale = MIN_SCALE;
    MIN_SCALE = newFitScale;
    MAX_SCALE = newFitScale * 5;
    updateHotspotVars();
    // Preserve zoom ratio across ordinary resize / orientation change
    scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * newFitScale / oldMinScale));
  }
  applyTransform();
});

// ══════════════════════════════════════════════════════════════════════
//  Keyboard
// ══════════════════════════════════════════════════════════════════════
document.addEventListener('keydown', e => {
  if (e.key === 'Escape') {
    closePanel();
    return;
  }
  /* Edit mode toggle — disabled
  if ((e.key === 'e' || e.key === 'E') && !e.ctrlKey && !e.metaKey && !e.altKey) {
    editMode = !editMode;
    viewport.classList.toggle('edit-mode', editMode);
    updateEditBanner();
  } */
});


// ══════════════════════════════════════════════════════════════════════
//  Init — runs once the map image is ready
// ══════════════════════════════════════════════════════════════════════
function init() {
  imgW = mapImage.naturalWidth;
  imgH = mapImage.naturalHeight;

  wrapper.style.width  = imgW + 'px';
  wrapper.style.height = imgH + 'px';
  mapImage.style.width  = imgW + 'px';
  mapImage.style.height = imgH + 'px';

  // On mobile, fix panel height first so all subsequent calculations use the
  // correct available area (avoids mismatch when offsetHeight hasn't settled yet).
  if (window.innerWidth <= 768) {
    panelH = detailPanel.offsetHeight || Math.round(window.innerHeight * 0.67);
    detailPanel.style.height = panelH + 'px';
  }

  const PANEL_W = getPanelW();
  const PANEL_H = getPanelH();
  const availW  = window.innerWidth  - PANEL_W;
  const availH  = window.innerHeight - PANEL_H;
  const fitScale = Math.min(availW / imgW, availH / imgH);
  MIN_SCALE = fitScale;
  MAX_SCALE = fitScale * 3;
  updateHotspotVars();

  scale = fitScale;
  tx = PANEL_W + (availW - imgW * scale) / 2;
  ty = (availH  - imgH * scale) / 2;

  applyTransform();

  // If places were already loaded before image finished, render now
  if (Object.keys(places).length > 0) buildHotspots();
}

if (mapImage.complete && mapImage.naturalWidth > 0) {
  init();
} else {
  mapImage.addEventListener('load', init);
  mapImage.addEventListener('error', () => {
    // Show an error inside the load card, not replacing the whole page
    document.querySelector('#load-card p').innerHTML =
      '<strong style="color:#c0392b">Map image not found.</strong><br>' +
      'Place <code>places_map_upscaled.png</code> in the <code>assets/</code> folder, then reload.';
  });
}
</script>
</body>
</html>
